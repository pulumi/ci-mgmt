permissions: write-all # Equivalent to default permissions plus id-token: write
name: Test Provider CI
on:
  pull_request:
    branches:
      - master
  merge_group: {}
  workflow_dispatch: {}

env:
  ESC_ACTION_OIDC_AUTH: true
  ESC_ACTION_OIDC_ORGANIZATION: pulumi
  ESC_ACTION_OIDC_REQUESTED_TOKEN_TYPE: urn:pulumi:token-type:access_token:organization
  ESC_ACTION_ENVIRONMENT: github-secrets/pulumi-ci-mgmt
  ESC_ACTION_EXPORT_ENVIRONMENT_VARIABLES: GITHUB_TOKEN=PULUMI_BOT_TOKEN

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Verify against testdata
    runs-on: ubuntu-latest
    steps:
      - name: Fetch secrets from ESC
        id: esc-secrets
        uses: pulumi/esc-action@cf5b30703ffd5ad60cc3a880c09b3a9592b9372d # v1
      - name: Checkout Repo
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      - name: Install golangci-lint
        uses: golangci/golangci-lint-action@55c2c1448f86e01eaae002a5a3a9624417608d84 # v6
        with:
          working-directory: provider-ci
      - name: Configure git
        # Set the default branch to silence the warnings about the default branch name changing
        # The branch doesn't matter here because it's only used for a temp repo for actionlint
        run: git config --global init.defaultBranch master
      - name: Build & test
        run: cd provider-ci && make all
      - name: Check worktree clean
        uses: pulumi/git-status-check-action@v1

  downstream:
    name: Test and release provider (${{ matrix.input.repo }})
    runs-on: ubuntu-latest
    env:
      ESC_ACTION_EXPORT_ENVIRONMENT_VARIABLES: GITHUB_TOKEN=PULUMI_BOT_TOKEN,GITHUB_TOKEN=PULUMI_BOT_TOKEN
    strategy:
      fail-fast: false
      matrix:
        input:
          - repo: pulumi/pulumi-xyz
            name: xyz
          - repo: pulumi/pulumi-provider-boilerplate
            name: provider-boilerplate
    steps:
      - name: Fetch secrets from ESC
        id: esc-secrets
        uses: pulumi/esc-action@cf5b30703ffd5ad60cc3a880c09b3a9592b9372d # v1

      - name: Apply ci-mgmt changes
        id: deploy
        uses: ./.github/workflows/update-workflows.yml
        with:
          provider_name: ${{ matrix.input.name }}
          automerge: ${{ github.event_name == 'merge_group' }}
          downstream_test: true
          skip_closing_prs: true
          caller_workflow: "pull-request"

      - name: Await PR opened for ${{ matrix.input.repo }}
        if: steps.deploy.outputs.pull_request_created == 'true'
        timeout-minutes: 5
        run: |
          echo Await PR opened for ${{ matrix.input.repo }}
          until gh search prs --repo ${{ matrix.input.repo }} --match body "This PR was automatically generated by the pull-request workflow in the pulumi/ci-mgmt repo, from commit ${{ github.sha }}."  --json url | grep url; do sleep 30; done;

      - name: Find PR number
        if: steps.deploy.outputs.pull_request_created == 'true'
        id: pr_number
        run: |
          number=$(gh search prs --repo ${{ matrix.input.repo }} --match body "This PR was automatically generated by the pull-request workflow in the pulumi/ci-mgmt repo, from commit ${{ github.sha }}."  --json number --jq '.[0].number')
          echo "PR number is $number"
          echo "number=${number}" >> "${GITHUB_OUTPUT}"

      - name: Add needs-release label
        if: steps.deploy.outputs.pull_request_created == 'true'
        run: gh pr edit --repo "${{ matrix.input.repo }}" "${{ steps.pr_number.outputs.number }}" --add-label "needs-release/patch"

      - name: Await first checks start
        if: steps.deploy.outputs.pull_request_created == 'true'
        timeout-minutes: 5
        # Wait for at least 3 checks to be started before we start waiting for them to finish.
        # There's a couple of quick checks like comment notification and changelog which are started before the PR checks.
        run: while [[ $(gh pr checks --repo "${{ matrix.input.repo }}" "${{ steps.pr_number.outputs.number }}" | wc -l) -le 2 ]]; do sleep 1; done

      - name: Await PR tests success
        if: steps.deploy.outputs.pull_request_created == 'true'
        timeout-minutes: 60
        run: gh pr checks --repo "${{ matrix.input.repo }}" "${{ steps.pr_number.outputs.number }}" --watch --fail-fast

        # The following steps are only run in the merge queue and confirm we
        # were able to successfully release.
      - name: Await PR merged
        if: github.event_name == 'merge_group' && steps.deploy.outputs.pull_request_created == 'true'
        run: while [[ $(gh pr view --repo "${{ matrix.input.repo }}" "${{ steps.pr_number.outputs.number }}" --json "state" --jq ".state") == "OPEN" ]]; do sleep 1; done
        timeout-minutes: 5

      - name: Get merge commit
        id: merge_commit
        if: github.event_name == 'merge_group' && steps.deploy.outputs.pull_request_created == 'true'
        run: |
          merge_commit_oid=$(gh pr view --repo "${{ matrix.input.repo }}" "${{ steps.pr_number.outputs.number }}" --json "mergeCommit" --jq ".mergeCommit.oid")
          if [[ -z "${merge_commit_oid}" ]]; then
            echo "Failed to get merge commit"
            exit 1
          fi
          echo "Merge commit oid is ${merge_commit_oid}"
          echo "oid=${merge_commit_oid}" >> "${GITHUB_OUTPUT}"

      - name: Await main build start
        if: github.event_name == 'merge_group' && steps.deploy.outputs.pull_request_created == 'true'
        id: main_build
        run: |
          until (gh run list --repo "${{ matrix.input.repo }}" --workflow main --json headSha | grep -q "${{ steps.merge_commit.outputs.oid }}"); do sleep 1; done
          database_id=$(gh run list --repo "${{ matrix.input.repo }}" --workflow main --json "number,headSha,databaseId" | jq '.[] | select(.headSha == "${{ steps.merge_commit.outputs.oid }}") | .databaseId')
          echo "Main build started with database id ${database_id}"
          echo "id=${database_id}" >> "${GITHUB_OUTPUT}"
        timeout-minutes: 5

      - name: Await main build success
        if: github.event_name == 'merge_group' && steps.deploy.outputs.pull_request_created == 'true'
        timeout-minutes: 60
        run: gh run watch --repo "${{ matrix.input.repo }}" "${{ steps.main_build.outputs.id }}" --exit-status

      - name: Get tag for release
        if: github.event_name == 'merge_group' && steps.deploy.outputs.pull_request_created == 'true'
        id: release_tag
        timeout-minutes: 5
        run: |
          until (git ls-remote --tags "https://github.com/${{ matrix.input.repo }}.git" | grep -q "${{ steps.merge_commit.outputs.oid }}"); do sleep 1; done
          # Also handle annotated tags in the format refs/tags/v0.1.0^{}
          tag=$(git ls-remote --tags "https://github.com/${{ matrix.input.repo }}.git" | grep "${{ steps.merge_commit.outputs.oid }}" | cut -d '/' -f 3 | sed -E 's/\^\{\}$//')
          echo "Tag for release is ${tag}"
          echo "tag=${tag}" >> "${GITHUB_OUTPUT}"

      - name: Await release workflow run
        if: github.event_name == 'merge_group' && steps.deploy.outputs.pull_request_created == 'true'
        id: release_workflow
        timeout-minutes: 5
        run: |
          until (gh run list --repo "${{ matrix.input.repo }}" --workflow release --branch "${{ steps.release_tag.outputs.tag }}" --json headBranch | grep -q "${{ steps.release_tag.outputs.tag }}"); do sleep 1; done
          database_id=$(gh run list --repo "${{ matrix.input.repo }}" --workflow release --branch "${{ steps.release_tag.outputs.tag }}" --json "databaseId" --jq '.[0].databaseId')
          echo "Release workflow started with id ${database_id}"
          echo "id=${database_id}" >> "${GITHUB_OUTPUT}"

      - name: Await release workflow success
        if: github.event_name == 'merge_group' && steps.deploy.outputs.pull_request_created == 'true'
        timeout-minutes: 60
        run: gh run watch --repo "${{ matrix.input.repo }}" "${{ steps.release_workflow.outputs.id }}" --exit-status
