package migrations

import (
	"fmt"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// migrates things from ci-mgmt.yaml to `.config/mise.toml`
type migrateCimgmtToMise struct{}

func (migrateCimgmtToMise) Name() string {
	return "Migrate ci-mgmt.yml entries to the default .config/mise.toml file"
}
func (migrateCimgmtToMise) ShouldRun(templateName string) bool {
	return true
}

const defaultConfigMiseToml = `# WARNING: This file is autogenerated - changes will be overwritten when regenerated by https://github.com/pulumi/ci-mgmt
# You can create your own root-level mise.toml file to override/augment this. See https://mise.jdx.dev/configuration.html

[env]
_.source = "{{config_root}}/scripts/get-versions.sh"
PULUMI_HOME = "{{config_root}}/.pulumi"

[tools]

# Runtimes
# TODO: we may not need 'get_env' once https://github.com/jdx/mise/discussions/6339 is fixed
go = "{{ get_env(name='GO_VERSION_MISE', default='latest') }}"
node = '20.19.5'
python = '3.11.8'
dotnet = '8.0.414'
# Corretto version used as Java SE/OpenJDK version no longer offered
java = 'corretto-11'

# Executable tools
pulumi = "{{ get_env(name='PULUMI_VERSION_MISE', default='latest') }}"
"github:pulumi/pulumictl" = '0.0.50'
"github:pulumi/schema-tools" = "0.6.0"
gradle = '7.6.0'
golangci-lint = "1.64.8" # See note about about overrides if you need to customize this.
"npm:yarn" = "1.22.22"

[settings]
experimental = true # Required for Go binaries (e.g. pulumictl).
lockfile = false
`

func (migrateCimgmtToMise) Migrate(templateName, outDir string) error {
	ciMgmtPath := filepath.Join(outDir, ".ci-mgmt.yaml")
	cimgmt, err := newCimgmtYaml(ciMgmtPath)
	if err != nil {
		return err
	}

	misePath := filepath.Join(outDir, ".config", "mise.toml")
	mise, err := newTomlFile(misePath)
	if err != nil {
		return err
	}

	needsWrite := false
	if len(strings.TrimSpace(string(mise.content))) == 0 {
		mise.content = []byte(defaultConfigMiseToml)
		needsWrite = true
	}

	plugins := cimgmt.getFieldNode("plugins")
	if plugins == nil {
		if needsWrite {
			return mise.writeFile()
		}
		return nil
	}

	// If we have any plugins overrides, move them to the .config/mise.toml
	pluginList := nodeToPluginEntries(plugins)
	entries := pluginsToToolEntries(pluginList)
	updatedTools, err := mise.ensureSectionEntries("tools", entries)
	if err != nil {
		return fmt.Errorf("error ensuring mise plugin entry: %w", err)
	}

	updatedPlugins := false
	if len(entries) > 0 {
		updatedPlugins, err = mise.ensureSectionEntries("plugins", []sectionEntry{
			{key: "vfox-pulumi", value: "https://github.com/pulumi/vfox-pulumi"},
		})
		if err != nil {
			return fmt.Errorf("error ensuring mise plugins entry: %w", err)
		}
	}

	if needsWrite || updatedTools || updatedPlugins {
		if err := mise.writeFile(); err != nil {
			return err
		}
	}

	cimgmt.deleteKey("plugins")
	return cimgmt.writeFile()
}

type cimgmtPluginEntry struct {
	Name    string
	Version string
	Kind    string
}

func nodeToPluginEntries(m *yaml.Node) []cimgmtPluginEntry {
	if m == nil || m.Kind != yaml.SequenceNode {
		return nil
	}

	out := make([]cimgmtPluginEntry, 0, len(m.Content))
	for _, entry := range m.Content {
		if entry.Kind != yaml.MappingNode {
			continue
		}
		var plugin cimgmtPluginEntry
		for i := 0; i < len(entry.Content); i += 2 {
			k := entry.Content[i]
			if i+1 >= len(entry.Content) {
				continue
			}
			v := entry.Content[i+1]
			switch k.Value {
			case "name":
				plugin.Name = v.Value
			case "version":
				plugin.Version = v.Value
			case "kind":
				plugin.Kind = v.Value
			}
		}
		out = append(out, plugin)
	}

	return out
}

func pluginsToToolEntries(plugins []cimgmtPluginEntry) []sectionEntry {
	if len(plugins) == 0 {
		return nil
	}

	entries := make([]sectionEntry, 0, len(plugins))
	index := make(map[string]int, len(plugins))
	for _, plugin := range plugins {
		repoName := fmt.Sprintf("pulumi-%s", plugin.Name)
		org := "pulumi"
		if plugin.Kind != "" {
			repoName = fmt.Sprintf("pulumi-%s-%s", plugin.Kind, plugin.Name)
		}
		// special handling for the `time` provider which is a pulumiverse provider
		// the plugins entry doesn't have any info on the GitHub org that the provider belongs to
		// so we have to hardcode it for the 1 time migration
		if plugin.Name == "time" {
			org = "pulumiverse"
		}
		name := fmt.Sprintf("vfox-pulumi:%s/%s", org, repoName)
		// Use the version from the plugin config if specified, otherwise default to latest
		version := plugin.Version
		if version == "" {
			version = "latest"
		}

		if pos, ok := index[name]; ok {
			entries[pos].value = version
			continue
		}

		index[name] = len(entries)
		entries = append(entries, sectionEntry{
			key:   name,
			value: version,
		})
	}

	return entries
}
