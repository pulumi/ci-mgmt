package migrations

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// moving the mise.toml file to the `.config` directory.
// This allows users to override the file by placing a mise file
// at the root of the repo. see https://mise.jdx.dev/configuration.html
type migrateMiseConfig struct{}

func (migrateMiseConfig) Name() string {
	return "Migrate old mise.toml file"
}
func (migrateMiseConfig) ShouldRun(templateName string) bool {
	return true
}

// This also migrates the tool overrides from .ci-mgmt.yaml to a root level
// mise.toml
func (migrateMiseConfig) Migrate(templateName, outDir string) error {
	ciMgmtPath := filepath.Join(outDir, ".ci-mgmt.yaml")
	ciMgmtFile, err := os.ReadFile(ciMgmtPath)
	if err != nil {
		return fmt.Errorf("error reading .ci-mgmt.yaml: %w", err)
	}

	var miseExists bool
	oldPath := filepath.Join(outDir, "mise.toml")
	oldFile, err := os.ReadFile(oldPath)
	if err == nil {
		miseExists = true
	}

	var ciMgmt yaml.Node
	if err := yaml.Unmarshal(ciMgmtFile, &ciMgmt); err != nil {
		return fmt.Errorf("error unmarshaling .ci-mgmt.yaml: %w", err)
	}
	toolVersions := getField(ciMgmt.Content[0], "toolVersions")
	// if we don't override any toolVersions and we don't have an existing root-level mise.toml
	// then we don't need to do anything
	if toolVersions == nil && !miseExists {
		return nil
	}

	// If the old root-level mise.toml exists, remove it first.
	if miseExists && strings.Contains(string(oldFile), "# WARNING: This file is autogenerated - changes will be overwritten when regenerated by https://github.com/pulumi/ci-mgmt") {
		if err := os.Remove(oldPath); err != nil {
			return fmt.Errorf("could not remove old mise.toml: %w", err)
		}
	}

	// If we have any toolVersions overrides, move them to a root-level mise.toml
	toolVersionsMap := nodeToMap(toolVersions)
	if toolVersionsMap != nil {
		var builder strings.Builder
		builder.WriteString("# Overwrites mise configuration at .config/mise.toml\n")
		builder.WriteString("[tools]\n")
		for tool, version := range toolVersionsMap {
			if tool == "go" {
				// don't use go overrides anymore
				continue
			}
			version = strings.TrimSuffix(version, ".x")
			if tool == "java" {
				version = fmt.Sprintf("corretto-%s", version)
			}
			builder.WriteString(fmt.Sprintf("%s = '%s'\n", tool, version))
		}
		if err := os.WriteFile(oldPath, []byte(builder.String()), 0644); err != nil {
			return fmt.Errorf("error writing mise.toml: %w", err)
		}
	}

	// Finally remove the toolVersions from .ci-mgmt.yaml
	deleteKey(&ciMgmt, "toolVersions")
	newCiMgmt, err := yaml.Marshal(&ciMgmt)
	if err != nil {
		return fmt.Errorf("error marshaling .ci-mgmt.yaml: %w", err)
	}
	if err := os.WriteFile(ciMgmtPath, newCiMgmt, 0644); err != nil {
		return fmt.Errorf("error writing .ci-mgmt.yaml: %w", err)
	}

	return nil
}

func deleteKey(m *yaml.Node, key string) {
	if m == nil {
		return
	}

	switch m.Kind {
	case yaml.DocumentNode:
		if len(m.Content) == 0 {
			return
		}
		deleteKey(m.Content[0], key)
	case yaml.MappingNode:
		out := m.Content[:0]
		for i := 0; i < len(m.Content); i += 2 {
			if i+1 >= len(m.Content) {
				continue
			}
			k := m.Content[i]
			v := m.Content[i+1]
			if k.Value == key {
				continue // skip this key/value pair (delete)
			}
			out = append(out, k, v)
		}
		m.Content = out
	}
}

func getField(m *yaml.Node, key string) *yaml.Node {
	if m.Kind != yaml.MappingNode {
		return nil
	}
	for i := 0; i < len(m.Content); i += 2 {
		k := m.Content[i]
		v := m.Content[i+1]
		if k.Value == key {
			return v
		}
	}
	return nil
}

func nodeToMap(m *yaml.Node) map[string]string {
	if m == nil {
		return nil
	}
	if m.Kind != yaml.MappingNode {
		return nil
	}
	out := make(map[string]string)
	for i := 0; i < len(m.Content); i += 2 {
		k := m.Content[i]
		v := m.Content[i+1]
		out[k.Value] = v.Value
	}
	return out
}
